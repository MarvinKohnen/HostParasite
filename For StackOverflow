
using Random
using Agents
using Agents.Pathfinding
using FileIO
using Distributions
using InteractiveDynamics
using Logging 


mutable struct CopepodGrazerParasiteStickleback <: AbstractAgent
    id::Int 
    pos::NTuple{2, Float64} 
    type::Symbol 
    energy::Float64
    reproduction_prob::Float64 
    infected::Int   
    infectiondays::Int
end


function Copepod(id, pos, repr, energy)
    CopepodGrazerParasiteStickleback(id, pos, :copepod, repr, energy, 0, 0)
end

function Grazer(id, pos, repr, energy)
    CopepodGrazerParasiteStickleback(id, pos, :grazer, repr, energy, 0, 0)
end

function Parasite(id, pos, repr, energy)
    CopepodGrazerParasiteStickleback(id, pos, :parasite, repr, energy, 0, 0)
end

function Stickleback(id, pos, repr)
    CopepodGrazerParasiteStickleback(id, pos, :stickleback, repr, 10, 0, 0)
end

eunorm(vec) = √sum(vec .^ 2)



function initialize_model(;
    #initial amount of Agents
    n_copepod = 100, 
    n_grazer = 160, 
    n_parasite = 4000,  
    n_stickleback = 10,

    # Energy 
    energy_copepod = 30, 
    energy_grazer = 30, 
    energy_parasite = 50,  

    #Vision Radius 
    copepod_vision = 6,  
    grazer_vision = 1,  
    parasite_vision = 2,  
    stickleback_vision = 8,  
    
    #Reproduction probability
    copepod_reproduce = 0.03,
    grazer_reproduce = 0.03,
    parasite_reproduce = 0, 
    stickleback_reproduce = 1.0, 

    # Movement rates 
    copepod_vel = 1.3,
    grazer_vel = 1.1,
    parasite_vel = 1.0,
    stickleback_vel = 1.4,

    hatch_prob = 0.2, #probability for parasite eggs to hatch
    seed = 23182,
    dt = 1.0,
    )


    rng = MersenneTwister(seed) #MersenneTwister: pseudo random number generator
    space = ContinuousSpace((100., 100.); periodic = true)


    dims = (1080, 1920) #used to make a video of this simulation, ignore this
    water_walkmap= BitArray(falses(dims)) #only need dims to set Walkmap for pathfinding 
 

    properties = Dict(
        :pathfinder => AStar(space; walkmap = water_walkmap),
        :n_copepod => n_copepod, 
        :n_grazer => n_grazer,
        :n_parasite => n_parasite,
        :n_stickleback => n_stickleback,
        :copepod_vision => copepod_vision,
        :grazer_vision => grazer_vision,
        :parasite_vision => parasite_vision,
        :stickleback_vision => stickleback_vision,
        :copepod_reproduce => copepod_reproduce,
        :grazer_reproduce => grazer_reproduce,
        :parasite_reproduce => parasite_reproduce, 
        :stickleback_reproduce => stickleback_reproduce,
        :hatch_prob => hatch_prob,
        :copepod_vel => copepod_vel,
        :grazer_vel => grazer_vel,
        :parasite_vel => parasite_vel,
        :stickleback_vel => stickleback_vel,
        :energy_copepod => energy_copepod,
        :energy_grazer => energy_grazer,
        :energy_parasite => energy_parasite,
        :dt => dt,
        :seed => seed,
    )
    
    model = ABM(CopepodGrazerParasiteStickleback, space; properties, rng, scheduler = Schedulers.randomly)  #Random Step order of agents! 
    
    for _ in 1:n_grazer
        add_agent_pos!(
            Grazer(
                nextid(model),
                random_walkable(random_position(model), model, model.pathfinder, model.grazer_vision),
                grazer_reproduce,
                energy_grazer,
            ),
            model,
        )
        
    end

    for _ in 1:n_copepod
        add_agent_pos!(
            Copepod(
                nextid(model),
                random_walkable(random_position(model), model, model.pathfinder, model.copepod_vision),
                copepod_reproduce,
                energy_copepod,
            ),
            model,
        )
    end

    for _ in 1:n_stickleback
        add_agent_pos!(
            Stickleback(
                nextid(model),
                random_walkable(random_position(model),model, model.pathfinder, model.stickleback_vision),
                stickleback_reproduce,
            ),
            model,
        )
    end
    
    for _ in 1:n_parasite
        add_agent_pos!(
            Parasite(
                nextid(model),
                random_walkable(random_position(model), model, model.pathfinder),
                parasite_reproduce,
                energy_parasite,
            ),
            model,
        )
    end
    return model
end

function agent_step!(agent::CopepodGrazerParasiteStickleback, model)  #agent
    if agent.type == :grazer 
        grazer_step!(agent, model)
    elseif agent.type == :copepod 
        copepod_step!(agent, model)
    elseif agent.type == :parasite
        parasite_step!(agent, model)
    elseif agent.type == :stickleback
        stickleback_step!(agent, model)
    end
end


function parasite_step!(parasite, model) 
    parasite.energy -= 1
    if parasite.energy < 0
        remove_agent!(parasite, model, model.pathfinder)
        return
    end
    walk!(parasite, rand, model) #periodic = false
end


function grazer_step!(grazer, model)
   
    if grazer.energy <= 15
        grazer.energy += 15
    end
    grazer.energy -=model.dt

    if grazer.energy < 0
        remove_agent!(grazer, model, model.pathfinder)
        return
    end
    
    if rand(model.rng) <= grazer.reproduction_prob * model.dt
        grazer_reproduce!(grazer, model)
    end
    
    walk!(grazer, rand, model) 
end


function copepod_step!(copepod, model) 

    if rand(model.rng) <= copepod.reproduction_prob * model.dt
        copepod_reproduce!(copepod, model)
    end
   
    if copepod.energy <= 15
        copepod_eat!(copepod, model)
    end
    copepod.energy -= model.dt
    
    if copepod.energy < 0
        remove_agent!(copepod, model, model.pathfinder)
        return
    end
    
    if copepod.infectiondays <= 2#13 

        #get an iterable of nearby prey and predators
        prey = [g.pos for g in nearby_agents(copepod, model, model.copepod_vision) if g.type == :grazer]
        cpredators = [s.pos for s in nearby_agents(copepod, model, model.copepod_vision) if s.type == :stickleback]
       
        #if there are predators nearby, override any other movement and flee from it 
        if !isempty(cpredators) 
            # Try and get an ideal direction away from predators
            direction = (0., 0.)
            for predator in cpredators
                # Get the direction away from the predator
                away_direction = (copepod.pos .- predator)
                # In case there is already a predator at our location, moving anywhere is
                # moving away from it, so it doesn't contribute to `direction`
                all(away_direction .≈ 0.) && continue
                # Add this to the overall direction, scaling inversely with distance.
                # As a result, closer predators contribute more to the direction to move in
                direction = direction .+ away_direction ./ eunorm(away_direction) ^ 2
            end
           
            if all(direction .≈ 0.)

                chosen_position = random_walkable(copeod.pos, model, model.pathfinder, model.copepod_vision)
            else
                
                direction = direction ./ eunorm(direction)
                
                position = copepod.pos .+ direction .* (model.copepod_vision / 2.)
                chosen_position = random_walkable(position, model, model.pathfinder, model.copepod_vision / 2.)
            end
            plan_route!(copepod, chosen_position, model.pathfinder)
        end
                
        #only if there are no predators nearby, the copepod will look for prey
        if !isempty(prey) && isempty(cpredators)
            direction = (0., 0.)
            for agent in prey
                toward_direction = (copepod.pos .+ agent)
                direction = direction .+ toward_direction ./ eunorm(toward_direction) ^ 2
            end

            if all(direction .≈ 0.)

                chosen_position = random_walkable(copeod.pos, model, model.pathfinder, model.copepod_vision)
            else
                
                direction = direction ./ eunorm(direction)
                
                position = copepod.pos .+ direction .* (model.copepod_vision / 2.)
                chosen_position = random_walkable(position, model, model.pathfinder, model.copepod_vision / 2.)
            end
            plan_route!(copepod, chosen_position, model.pathfinder)
        end

        #if no prey and no predator nearby, move to a random location
        if is_stationary(copepod, model.pathfinder)
            plan_route!(
                copepod,
                random_walkable(copepod.pos, model, model.pathfinder, model.copepod_vision),
                model.pathfinder,
            )
        end

    # if the copepod is infected for more than 12 days 
    else 
        #get an iterable of nearby prey and predators
        prey = [g.pos for g in nearby_agents(copepod, model, model.copepod_vision) if g.type == :grazer]
        cpredators = [s.pos for s in nearby_agents(copepod, model, model.copepod_vision) if s.type == :stickleback]

        if !isempty(cpredators) 
            # Try and get an ideal direction away from predators
            direction = (0., 0.)
            for predator in cpredators
                # Get the direction away from the predator
                away_direction = (copepod.pos .- predator)
                # In case there is already a predator at our location, moving anywhere is
                # moving away from it, so it doesn't contribute to `direction`
                all(away_direction .≈ 0.) && continue
                # Add this to the overall direction, scaling inversely with distance.
                # As a result, closer predators contribute more to the direction to move in
                direction = direction .+ away_direction ./ eunorm(away_direction) ^ 2
            end

            #the infected copepod exudes risk behaviour
            if !isempty(prey) 
                direction = (0.,0.)
                for agent in prey
                    toward_direction = (copepod.pos .+ agent)
                    direction = direction .+ toward_direction ./ eunorm(toward_direction) ^ 2
                end
            end 

            if all(direction .≈ 0.)

                chosen_position = random_walkable(copeod.pos, model, model.pathfinder, model.copepod_vision)
            else
                
                direction = direction ./ eunorm(direction)
                
                position = copepod.pos .+ direction .* (model.copepod_vision / 2.)
                chosen_position = random_walkable(position, model, model.pathfinder, model.copepod_vision / 2.)
            end
            plan_route!(copepod, chosen_position, model.pathfinder)
        end

        if !isempty(prey) && isempty(cpredators)
            direction = (0.,0.)
            for agent in prey
                toward_direction = (copepod.pos .+ agent)
                direction = direction .+ toward_direction ./ eunorm(toward_direction) ^ 2
            end

            if all(direction .≈ 0.)

                chosen_position = random_walkable(copeod.pos, model, model.pathfinder, model.copepod_vision)
            else
                
                direction = direction ./ eunorm(direction)
                
                position = copepod.pos .+ direction .* (model.copepod_vision / 2.)
                chosen_position = random_walkable(position, model, model.pathfinder, model.copepod_vision / 2.)
            end
            plan_route!(copepod, chosen_position, model.pathfinder)
        end

        #if no prey and no predator nearby, move to a random location
        if is_stationary(copepod, model.pathfinder)
            plan_route!(
                copepod,
                random_walkable(copepod.pos, model, model.pathfinder, model.copepod_vision),
                model.pathfinder,
            )
        end
    end
        
    if copepod.infected == 1
        move_along_route!(copepod, model, model.pathfinder, model.copepod_vel, model.dt)
        copepod_eat!(copepod, model)
        copepod.infectiondays +=1
        copepod.energy -= model.dt
    end

    move_along_route!(copepod, model, model.pathfinder, model.copepod_vel, model.dt) 
end


function stickleback_step!(stickleback, model) 
    #stickleback_infection!(stickleback, model)
    if (stickleback.infected == 1) && (rand(model.rng) <= stickleback.reproduction_prob) 
        parasite_reproduce!(model)
        stickleback.infected = 0
    end

    if is_stationary(stickleback, model.pathfinder)
        hunt = [x for x in nearby_agents(stickleback, model, model.stickleback_vision) if x.type == :copepod || x.type == :grazer]
        if isempty(hunt)
          
            plan_route!(
                stickleback,
                random_walkable(stickleback.pos, model, model.pathfinder, model.stickleback_vision),
                model.pathfinder,
            )
        else
            # Move toward a random agent in hunt
            plan_route!(stickleback, rand(model.rng, map(x -> x.pos, hunt)), model.pathfinder)
        end   
    end

    move_along_route!(stickleback, model, model.pathfinder, model.stickleback_vel, model.dt) 

    stickleback_eat!(stickleback, model) 
    
end


function stickleback_eat!(stickleback, model)

    eat = [x for x in nearby_agents(stickleback, model, model.stickleback_vision) if x.type == :copepod || x.type == :grazer]
    if !isempty(eat)
        for x in eat
            if x.infected == 1
                stickleback.infected = 1
            end
            remove_agent!(x, model, model.pathfinder)
        end
    end
end 


function copepod_eat!(copepod, model) 
    food = [x for x in nearby_agents(copepod, model, model.copepod_vision) if (x.type == :grazer)]
    if !isempty(food)  
        for x in food 
            remove_agent!(x, model, model.pathfinder)
            copepod.energy += 5
        end
    end


    infection = [x for x in nearby_agents(copepod, model, model.copepod_vision) if x.type == :parasite]
    if !isempty(infection)
        for x in infection
            remove_agent!(x, model, model.pathfinder)
            copepod.infected = 1
        end
    end
end

function grazer_reproduce!(grazer, model) 
    for _ in 1:rand(1:5)
        id = nextid(model)
        offspring = CopepodGrazerParasiteStickleback(
            id,
            random_position(model),
            grazer.type,
            model.energy_grazer,
            grazer.reproduction_prob,
            0,
            0
        )
    add_agent_pos!(offspring, model)
    end
    return
end

function copepod_reproduce!(copepod, model) 
    for _ in 1:(rand(1:5))
        id = nextid(model)
        offspring = CopepodGrazerParasiteStickleback(
            id,
            copepod.pos,
            copepod.type,
            model.energy_copepod,
            copepod.reproduction_prob,
            0,
            0
        )
    add_agent_pos!(offspring, model)
    end
    return
end

function parasite_reproduce!(model)
    print("parasite reproduced")
    epg = 200 
    energy_parasite = 96
    parasite_reproduce = 0
    for _ in 1:epg
        if rand(model.rng) <= model.hatch_prob
            id = nextid(model)
            egg = Parasite(
                id,
                random_walkable(random_position(model), model, model.pathfinder),
                parasite_reproduce,
                energy_parasite,
            )
            add_agent!(egg, model)
        end
    end
    return
end

grazer(a) = a.type == :grazer
copepod(a) = a.type == :copepod && a.infected == 0
copepodInf(a) = a.type == :copepod
parasite(a) = a.type == :parasite
stickleback(a) = a.type == :stickleback
sticklebackInf(a) = a.type ==:stickleback && a.infected == 1

#main
n= 30
model = initialize_model()

adata = [(grazer, count), (parasite, count), (copepod, count), (copepodInf, count), (stickleback, count), (sticklebackInf, count)]
adf = run!(model, agent_step!, n; adata)
adf = adf[1]

show(adf, allrows=true)